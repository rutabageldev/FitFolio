name: CD - Staging and Promote

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Immutable image tag (e.g., sha-<commit>)'
        required: true
      extended_smoke:
        description: 'Run extended auth smoke (/_debug/mail) if enabled'
        required: false
        default: 'false'
      bypass_ci_gate:
        description: 'Bypass CI success requirement (manual runs only)'
        required: false
        default: 'false'
  workflow_run:
    workflows: ['CI']
    branches:
      - main
    types:
      - completed

env:
  GHCR_OWNER: rutabageldev
  GHCR_REPO: fitfolio

jobs:
  require-ci:
    name: Require CI Success
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
    # Skip this job only when workflow_dispatch with bypass flag
    if: >
      github.event_name != 'workflow_dispatch' || github.event.inputs.bypass_ci_gate != 'true'
    steps:
      - name: Check workflow_run conclusion (if triggered by workflow_run)
        if: github.event_name == 'workflow_run'
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
            echo "CI workflow did not succeed: ${{ github.event.workflow_run.conclusion }}"
            exit 1
          fi
          echo "CI workflow succeeded, proceeding with deployment"

      - name: Check latest CI run for this commit
        if: github.event_name != 'workflow_run'
        uses: actions/github-script@v7
        with:
          script: |
            const sha = context.sha;
            const { owner, repo } = context.repo;
            const runs = await github.rest.actions.listWorkflowRunsForRepo({
              owner, repo, per_page: 50, head_sha: sha
            });
            const ciRun = runs.data.workflow_runs.find(r => r.name === "CI" && r.head_sha === sha);
            if (!ciRun) {
              core.setFailed("No CI run found for this commit.");
              return;
            }
            if (ciRun.status !== "completed" || ciRun.conclusion !== "success") {
              core.setFailed(`CI run not successful: status=${ciRun.status} conclusion=${ciRun.conclusion}`);
            } else {
              core.info("CI success verified.");
            }

  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    needs: require-ci
    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Set IMAGE_TAG
        id: tag
        run: |
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            echo "IMAGE_TAG=${{ github.event.inputs.image_tag }}" >> $GITHUB_ENV
            echo "image_tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            TAG="sha-$(git rev-parse --short=12 HEAD)"
            echo "IMAGE_TAG=$TAG" >> $GITHUB_ENV
            echo "image_tag=$TAG" >> $GITHUB_OUTPUT
          fi

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push backend
        uses: docker/build-push-action@v5
        with:
          context: .
          file: backend/Dockerfile.prod
          push: true
          tags: |
            ghcr.io/${{ env.GHCR_OWNER }}/${{ env.GHCR_REPO }}/backend:${{ env.IMAGE_TAG }}

      - name: Build and push frontend
        uses: docker/build-push-action@v5
        with:
          context: .
          file: frontend/Dockerfile.prod
          push: true
          tags: |
            ghcr.io/${{ env.GHCR_OWNER }}/${{ env.GHCR_REPO }}/frontend:${{ env.IMAGE_TAG }}

  deploy-staging:
    name: Deploy to Staging
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - uses: actions/checkout@v4
      - name: Set IMAGE_TAG
        run: echo "IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}" >> $GITHUB_ENV
      - name: Sync stack file to staging host
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.STAGING_SSH_HOST }}
          username: ${{ secrets.STAGING_SSH_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: 2222
          source: 'deploy/stack.staging.yml'
          target: '${{ secrets.STAGING_APP_DIR }}'
          strip_components: 1
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.1.0
        with:
          host: ${{ secrets.STAGING_SSH_HOST }}
          username: ${{ secrets.STAGING_SSH_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: 2222
          script: |
            set -euo pipefail
            export GHCR_OWNER=${{ env.GHCR_OWNER }}
            export GHCR_REPO=${{ env.GHCR_REPO }}
            export IMAGE_TAG=${{ env.IMAGE_TAG }}
            # Login to GHCR using fine-grained read-only token
            docker login ghcr.io -u "${{ secrets.STAGING_GHCR_READ_USER }}" -p "${{ secrets.STAGING_GHCR_READ_TOKEN }}"
            cd "${{ secrets.STAGING_APP_DIR }}"
            # Deploy or update the stack with current IMAGE_TAG
            IMAGE_TAG="${IMAGE_TAG}" docker stack deploy -c stack.staging.yml fitfolio-staging
            # Wait for backend container to be running and healthy
            echo "Waiting for backend container to be ready and healthy..."
            cid=""
            for i in {1..60}; do
              cid=$(docker ps --filter "name=fitfolio-staging_backend" --filter "status=running" --format '{{.ID}}' | head -n1)
              if [ -n "$cid" ]; then
                # Check if container is healthy
                health=$(docker inspect --format='{{.State.Health.Status}}' "$cid" 2>/dev/null || echo "none")
                if [ "$health" = "healthy" ]; then
                  echo "Backend container found and healthy: $cid"
                  break
                elif [ "$health" = "none" ]; then
                  echo "Backend container has no healthcheck, proceeding anyway: $cid"
                  break
                else
                  echo "Waiting for healthy status (currently: $health)... ($i/60)"
                fi
              else
                echo "Waiting for container to start... ($i/60)"
              fi
              sleep 2
            done
            # Run DB migrations
            if [ -n "$cid" ]; then
              echo "Checking database migration state..."
              # Lightweight check and stamp using direct SQL to avoid OOM from loading all models
              docker exec -i "$cid" bash -lc '
                python3 -c "
import os
import psycopg
from app.core.secrets import get_database_url

db_url = get_database_url() if os.getenv(\"USE_DOCKER_SECRETS\", \"\").lower() in (\"true\", \"1\", \"yes\") else os.getenv(\"DATABASE_URL\")
db_url = db_url.replace(\"postgresql+psycopg://\", \"postgresql://\")

# Get the head revision without loading models
import configparser
config = configparser.ConfigParser()
config.read(\"/app/alembic.ini\")

# Find the latest migration file
import os
from pathlib import Path
migrations_dir = Path(\"/app/migrations/versions\")
migration_files = sorted(migrations_dir.glob(\"*.py\"), reverse=True)
if migration_files:
    # Extract revision from first line of latest migration file
    with open(migration_files[0]) as f:
        for line in f:
            if \"Revision ID:\" in line:
                head_revision = line.split(\":\")[1].strip()
                break
else:
    head_revision = None

try:
    with psycopg.connect(db_url) as conn:
        with conn.cursor() as cur:
            # Check if alembic_version table exists
            cur.execute(\"SELECT EXISTS(SELECT FROM information_schema.tables WHERE table_name=\047alembic_version\047)\")
            table_exists = cur.fetchone()[0]

            # Check if user tables exist (indicates schema is present)
            cur.execute(\"SELECT EXISTS(SELECT FROM information_schema.tables WHERE table_name=\047users\047)\")
            users_table_exists = cur.fetchone()[0]

            if users_table_exists and not table_exists and head_revision:
                # Schema exists but no version tracking - stamp directly with SQL
                print(f\"Stamping database to {head_revision} using direct SQL...\")
                cur.execute(\"CREATE TABLE alembic_version (version_num VARCHAR(32) NOT NULL, CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num))\")
                cur.execute(\"INSERT INTO alembic_version (version_num) VALUES (%s)\", (head_revision,))
                conn.commit()
                print(\"Database stamped successfully via SQL\")
            elif users_table_exists and table_exists:
                cur.execute(\"SELECT version_num FROM alembic_version\")
                result = cur.fetchone()
                print(f\"Database already tracked at version: {result[0] if result else \047empty\047}\")
            else:
                print(\"Fresh database - ready for migrations\")
except Exception as e:
    print(f\"Error during version check/stamp: {e}\")
    import traceback
    traceback.print_exc()
"
              '

              echo "Running Alembic upgrade..."
              if docker exec -i "$cid" bash -lc 'alembic -c /app/alembic.ini upgrade head'; then
                echo "Migrations completed successfully"
              else
                echo "Migration upgrade failed"
                exit 1
              fi
            else
              echo "No healthy backend container found after 120 seconds" >&2
              exit 1
            fi

  smoke-staging:
    name: Smoke Tests (Staging)
    needs: deploy-staging
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run smoke test script
        run: bash scripts/smoke_deploy.sh "https://staging.fitfolio.rutabagel.com" "${{ github.event.inputs.extended_smoke || 'false' }}"

  promote-prod:
    name: Promote to Production (Manual)
    needs: smoke-staging
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://fitfolio.rutabagel.com
    steps:
      - uses: actions/checkout@v4
      - name: Set IMAGE_TAG
        run: echo "IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}" >> $GITHUB_ENV
      - name: Sync compose files to prod host
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.PROD_SSH_HOST }}
          username: ${{ secrets.PROD_SSH_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          port: 2222
          source: 'compose.prod.yml'
          target: '${{ secrets.PROD_APP_DIR }}'
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.1.0
        with:
          host: ${{ secrets.PROD_SSH_HOST }}
          username: ${{ secrets.PROD_SSH_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          port: 2222
          script: |
            set -euo pipefail
            export GHCR_OWNER=${{ env.GHCR_OWNER }}
            export GHCR_REPO=${{ env.GHCR_REPO }}
            export IMAGE_TAG=${{ env.IMAGE_TAG }}
            docker login ghcr.io -u ${{ github.actor }} -p ${{ secrets.GITHUB_TOKEN }}
            cd "${{ secrets.PROD_APP_DIR }}"
            docker compose -f compose.prod.yml pull
            docker compose -f compose.prod.yml up -d
            docker compose -f compose.prod.yml exec -T backend bash -lc "alembic -c /app/alembic.ini upgrade head"
