name: CD - Staging and Promote

on:
  workflow_dispatch:
    inputs:
      extended_smoke:
        description: 'Run extended auth smoke (/_debug/mail) if enabled'
        required: false
        default: 'false'
  workflow_run:
    workflows: ['CI - Quality Gate', 'CD - Build and Push Images']
    branches:
      - main
    types:
      - completed

concurrency:
  group: promote-${{ github.event.workflow_run.head_sha || github.sha }}
  cancel-in-progress: true

env:
  GHCR_OWNER: rutabageldev
  GHCR_REPO: fitfolio

jobs:
  gate:
    name: Validate Build & CI
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      actions: read
      contents: read
    outputs:
      image_tag: ${{ steps.compute_tag.outputs.image_tag }}
      skip: ${{ steps.idempotent.outputs.skip }}
      head_sha: ${{ steps.determine_sha.outputs.sha }}
    steps:
      - name: Determine head SHA
        id: determine_sha
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "sha=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
          else
            echo "sha=${GITHUB_SHA}" >> $GITHUB_OUTPUT
          fi

      - name: Resolve workflow ids
        id: workflow_ids
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const ciName = 'CI - Quality Gate';
            const buildName = 'CD - Build and Push Images';
            const workflows = await github.rest.actions.listRepoWorkflows({
              owner,
              repo,
              per_page: 100,
            });
            const ciWorkflow = workflows.data.workflows.find((wf) => wf.name === ciName);
            const buildWorkflow = workflows.data.workflows.find((wf) => wf.name === buildName);
            if (!ciWorkflow || !buildWorkflow) {
              core.setFailed(`Unable to resolve workflow ids (ci: ${ciWorkflow?.id}, build: ${buildWorkflow?.id})`);
              return;
            }
            core.setOutput('ci_id', ciWorkflow.id.toString());
            core.setOutput('build_id', buildWorkflow.id.toString());

      - name: Enforce idempotency
        id: idempotent
        uses: actions/github-script@v7
        with:
          script: |
            const sha = '${{ steps.determine_sha.outputs.sha }}';
            const { owner, repo } = context.repo;
            const workflowName = 'CD - Staging and Promote';

            const runs = await github.rest.actions.listWorkflowRunsForRepo({
              owner,
              repo,
              per_page: 50,
              head_sha: sha,
              status: 'completed',
            });

            const prior = runs.data.workflow_runs.find(
              (run) =>
                run.name === workflowName &&
                run.head_sha === sha &&
                run.conclusion === 'success'
            );

            if (prior) {
              core.notice(`Promotion for ${sha} already succeeded in run #${prior.id}. Skipping.`);
              core.setOutput('skip', 'true');
            } else {
              core.setOutput('skip', 'false');
            }

      - name: Compute image tag
        id: compute_tag
        if: steps.idempotent.outputs.skip != 'true'
        run: |
          SHA=${{ steps.determine_sha.outputs.sha }}
          TAG="sha-${SHA:0:12}"
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=$TAG" >> $GITHUB_ENV

      - name: Confirm triggering workflow succeeded
        if: github.event_name == 'workflow_run'
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
            echo "Triggering workflow did not succeed: ${{ github.event.workflow_run.conclusion }}"
            exit 1
          fi

      - name: Wait for CI success
        if: steps.idempotent.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const sha = '${{ steps.determine_sha.outputs.sha }}';
            const workflowId = parseInt('${{ steps.workflow_ids.outputs.ci_id }}', 10);
            const { owner, repo } = context.repo;
            const maxAttempts = 30;
            const delayMs = 10000;

            async function sleep(ms) {
              return new Promise((resolve) => setTimeout(resolve, ms));
            }

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner,
                repo,
                workflow_id: workflowId,
                per_page: 20,
                head_sha: sha,
              });
              const ciRun = runs.data.workflow_runs.find((run) => run.head_sha === sha);

              if (!ciRun) {
                core.info(`Attempt ${attempt}: CI run not found yet for ${sha}; waiting...`);
              } else if (ciRun.status !== 'completed') {
                core.info(`Attempt ${attempt}: CI status ${ciRun.status}; waiting...`);
              } else if (ciRun.conclusion !== 'success') {
                core.setFailed(`CI run concluded with ${ciRun.conclusion} for ${sha}`);
                return;
              } else {
                core.info(`CI success verified via run ${ciRun.id}`);
                return;
              }

              if (attempt === maxAttempts) {
                core.setFailed(`CI run did not complete within timeout for ${sha}`);
                return;
              }
              await sleep(delayMs);
            }

      - name: Wait for Build success
        if: steps.idempotent.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const sha = '${{ steps.determine_sha.outputs.sha }}';
            const workflowId = parseInt('${{ steps.workflow_ids.outputs.build_id }}', 10);
            const { owner, repo } = context.repo;
            const maxAttempts = 30;
            const delayMs = 10000;

            async function sleep(ms) {
              return new Promise((resolve) => setTimeout(resolve, ms));
            }

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner,
                repo,
                workflow_id: workflowId,
                per_page: 20,
                head_sha: sha,
              });
              const buildRun = runs.data.workflow_runs.find((run) => run.head_sha === sha);

              if (!buildRun) {
                core.info(`Attempt ${attempt}: Build run not found yet for ${sha}; waiting...`);
              } else if (buildRun.status !== 'completed') {
                core.info(`Attempt ${attempt}: Build status ${buildRun.status}; waiting...`);
              } else if (buildRun.conclusion !== 'success') {
                core.setFailed(`Build run concluded with ${buildRun.conclusion} for ${sha}`);
                return;
              } else {
                core.info(`Build success verified via run ${buildRun.id}`);
                return;
              }

              if (attempt === maxAttempts) {
                core.setFailed(`Build run did not complete within timeout for ${sha}`);
                return;
              }
              await sleep(delayMs);
            }

      - name: Verify images exist in GHCR
        if: steps.idempotent.outputs.skip != 'true'
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin
          docker manifest inspect ghcr.io/${{ env.GHCR_OWNER }}/${{ env.GHCR_REPO }}/backend:${IMAGE_TAG} >/dev/null
          docker manifest inspect ghcr.io/${{ env.GHCR_OWNER }}/${{ env.GHCR_REPO }}/frontend:${IMAGE_TAG} >/dev/null

  deploy-staging:
    name: Deploy to Staging
    needs: gate
    if: needs.gate.outputs.skip != 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment: staging
    outputs:
      image_tag: ${{ needs.gate.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4
      - name: Use IMAGE_TAG from gate
        run: |
          echo "IMAGE_TAG=${{ needs.gate.outputs.image_tag }}" >> $GITHUB_ENV
      - name: Sync stack file to staging host
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.STAGING_SSH_HOST }}
          username: ${{ secrets.STAGING_SSH_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: 2222
          source: 'deploy/stack.staging.yml'
          target: '${{ secrets.STAGING_APP_DIR }}'
          strip_components: 1
      - name: Sync scripts to staging host
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.STAGING_SSH_HOST }}
          username: ${{ secrets.STAGING_SSH_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: 2222
          source: 'scripts/'
          target: '${{ secrets.STAGING_APP_DIR }}'
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.1.0
        with:
          host: ${{ secrets.STAGING_SSH_HOST }}
          username: ${{ secrets.STAGING_SSH_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: 2222
          script: |
            set -euo pipefail
            export GHCR_OWNER=${{ env.GHCR_OWNER }}
            export GHCR_REPO=${{ env.GHCR_REPO }}
            export IMAGE_TAG=${{ env.IMAGE_TAG }}
            # Login to GHCR using fine-grained read-only token
            docker login ghcr.io -u "${{ secrets.STAGING_GHCR_READ_USER }}" -p "${{ secrets.STAGING_GHCR_READ_TOKEN }}"
            cd "${{ secrets.STAGING_APP_DIR }}"
            # Deploy the stack (backend will start but we'll run migrations first)
            IMAGE_TAG="${IMAGE_TAG}" docker stack deploy -c stack.staging.yml fitfolio-staging

            echo "Waiting for database to be ready..."
            # Wait for PostgreSQL to be ready (max 60 seconds)
            db_ready=false
            for i in {1..30}; do
              db_cid=$(docker ps --filter "name=fitfolio-staging_db" --filter "status=running" --format '{{.ID}}' | head -n1)
              if [ -n "$db_cid" ]; then
                if docker exec -i "$db_cid" pg_isready -h localhost -p 5432 >/dev/null 2>&1; then
                  echo "PostgreSQL is ready!"
                  db_ready=true
                  break
                fi
              fi
              echo "PostgreSQL not ready yet, waiting... ($i/30)"
              sleep 2
            done

            if [ "$db_ready" = false ]; then
              echo "ERROR: PostgreSQL did not become ready within 60 seconds"
              exit 1
            fi

            echo ""
            echo "Running database migrations in one-off container..."
            # Create a one-off service for migrations (not in the app workers)
            # This avoids OOM from running migrations alongside 4 gunicorn workers
            docker service rm fitfolio-staging-migrate 2>/dev/null || true

            docker service create \
              --name fitfolio-staging-migrate \
              --network fitfolio-staging_default \
              --secret source=postgres_password_staging,target=postgres_password,mode=0444 \
              --secret source=smtp_username_staging,target=smtp_username,mode=0444 \
              --secret source=smtp_password_staging,target=smtp_password,mode=0444 \
              --env POSTGRES_HOST=db \
              --env POSTGRES_PORT=5432 \
              --env POSTGRES_DB=fitfolio_staging \
              --env POSTGRES_USER=fitfolio_user \
              --env USE_DOCKER_SECRETS=true \
              --env PYTHONUNBUFFERED=1 \
              --restart-condition none \
              --with-registry-auth \
              --detach \
              ghcr.io/${GHCR_OWNER}/${GHCR_REPO}/backend:${IMAGE_TAG} \
              bash -c 'python3 -u /app/scripts/preflight_check.py && python3 -u /app/scripts/db_stamp_check.py && alembic -c /app/alembic.ini upgrade head'

            # Wait for migration service to complete (max 5 minutes)
            echo "Waiting for migrations to complete (max 300s)..."
            migration_complete=false
            for i in {1..150}; do
              state=$(docker service ps fitfolio-staging-migrate --format '{{.CurrentState}}' --filter "desired-state=shutdown" 2>/dev/null | head -n1 || true)
              tasks=$(docker service ps fitfolio-staging-migrate --no-trunc --filter "desired-state=shutdown" 2>/dev/null || true)
              completed=$(printf '%s\n' "$tasks" | grep -c "Complete" || true)
              if echo "$state" | grep -q "Complete" && [ "$completed" -ge 1 ]; then
                echo "Migrations completed successfully!"
                migration_complete=true
                break
              elif echo "$state" | grep -q "Failed"; then
                echo "ERROR: Migration service failed"
                docker service logs fitfolio-staging-migrate
                docker service rm fitfolio-staging-migrate
                exit 1
              fi
              echo "Migration still running... ($i/150)"
              sleep 2
            done

            # Show migration logs
            echo ""
            echo "=== Migration logs ==="
            docker service logs fitfolio-staging-migrate

            # Clean up migration service (always remove, success or failure)
            docker service rm fitfolio-staging-migrate

            # Check if migrations timed out
            if [ "$migration_complete" = false ]; then
              echo "ERROR: Migration did not complete within 300 seconds"
              exit 1
            fi

            echo "Allowing backend to settle before health checks..."
            sleep 5

            echo ""
            echo "Waiting for backend to be healthy..."
            # Now wait for backend to be running and healthy
            cid=""
            for i in {1..60}; do
              cid=$(docker ps --filter "name=fitfolio-staging_backend" --filter "status=running" --format '{{.ID}}' | head -n1)
              if [ -n "$cid" ]; then
                health=$(docker inspect --format='{{.State.Health.Status}}' "$cid" 2>/dev/null || echo "none")
                if [ "$health" = "healthy" ]; then
                  echo "Backend container is healthy: $cid"
                  break
                elif [ "$health" = "none" ]; then
                  echo "Backend container has no healthcheck, proceeding anyway: $cid"
                  break
                else
                  echo "Waiting for healthy status (currently: $health)... ($i/60)"
                fi
              else
                echo "Waiting for backend to start... ($i/60)"
              fi
              sleep 2
            done

            if [ -z "$cid" ]; then
              echo "ERROR: Backend did not become healthy within 120 seconds" >&2
              exit 1
            fi

            echo ""
            echo "Waiting for Traefik to obtain Let's Encrypt certificate..."
            # Poll for valid certificate (DNS-01 challenge takes 10-20 seconds typically)
            cert_valid=false
            for i in {1..4}; do
              echo "Checking certificate validity (attempt $i/4)..."
              if curl -fsS --max-time 5 https://fitfolio-staging.rutabagel.com/ >/dev/null 2>&1; then
                echo "Certificate is valid!"
                cert_valid=true
                break
              else
                echo "Certificate not ready yet, waiting 10 seconds..."
                sleep 10
              fi
            done

            if [ "$cert_valid" = false ]; then
              echo "WARNING: Certificate still not valid after 40 seconds, but continuing..."
              echo "This may cause smoke tests to fail. Check Traefik logs for certificate errors."
            fi

            echo "Deployment successful!"

  smoke-staging:
    name: Smoke Tests (Staging)
    needs: deploy-staging
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: needs.deploy-staging.result == 'success'
    steps:
      - uses: actions/checkout@v4
      - name: Run smoke tests via SSH
        uses: appleboy/ssh-action@v1.1.0
        with:
          host: ${{ secrets.STAGING_SSH_HOST }}
          username: ${{ secrets.STAGING_SSH_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: 2222
          script: |
            set -euo pipefail
            cd "${{ secrets.STAGING_APP_DIR }}"

            # Copy smoke script from repo (already synced during deploy)
            if [ ! -f scripts/smoke_deploy.sh ]; then
              echo "ERROR: smoke_deploy.sh not found in ${{ secrets.STAGING_APP_DIR }}/scripts/"
              exit 1
            fi

            # Debug DNS resolution first to help troubleshooting
            echo "=== DNS Debug ==="
            echo "Checking /etc/resolv.conf:"
            cat /etc/resolv.conf || echo "Cannot read resolv.conf"
            echo ""
            echo "Testing DNS resolution:"
            nslookup fitfolio-staging.rutabagel.com || echo "nslookup failed"
            host fitfolio-staging.rutabagel.com || echo "host command failed"
            getent hosts fitfolio-staging.rutabagel.com || echo "getent failed"
            echo ""
            echo "Checking /etc/hosts:"
            grep -i fitfolio /etc/hosts || echo "Not in /etc/hosts"
            echo ""
            echo "=== End DNS Debug ==="
            echo ""

            # Run smoke tests - if DNS doesn't work, this will fail (as it should)
            bash scripts/smoke_deploy.sh "https://fitfolio-staging.rutabagel.com" "${{ github.event.inputs.extended_smoke || 'false' }}"

  staging-success:
    name: Staging Success
    needs: smoke-staging
    runs-on: ubuntu-latest
    if: needs.smoke-staging.result == 'success'
    steps:
      - name: Record success
        run: |
          echo "## Staging Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Commit: $GITHUB_SHA" >> $GITHUB_STEP_SUMMARY
          echo "- Image tag: ${{ needs.deploy-staging.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
