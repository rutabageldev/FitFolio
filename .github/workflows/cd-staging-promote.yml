name: CD - Staging and Promote

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Immutable image tag (e.g., sha-<commit>)'
        required: true
      extended_smoke:
        description: 'Run extended auth smoke (/_debug/mail) if enabled'
        required: false
        default: 'false'
      bypass_ci_gate:
        description: 'Bypass CI success requirement (manual runs only)'
        required: false
        default: 'false'
  workflow_run:
    workflows: ['CI']
    branches:
      - main
    types:
      - completed

env:
  GHCR_OWNER: rutabageldev
  GHCR_REPO: fitfolio

jobs:
  require-ci:
    name: Require CI Success
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
    # Skip this job only when workflow_dispatch with bypass flag
    if: >
      github.event_name != 'workflow_dispatch' || github.event.inputs.bypass_ci_gate != 'true'
    steps:
      - name: Check workflow_run conclusion (if triggered by workflow_run)
        if: github.event_name == 'workflow_run'
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
            echo "CI workflow did not succeed: ${{ github.event.workflow_run.conclusion }}"
            exit 1
          fi
          echo "CI workflow succeeded, proceeding with deployment"

      - name: Check latest CI run for this commit
        if: github.event_name != 'workflow_run'
        uses: actions/github-script@v7
        with:
          script: |
            const sha = context.sha;
            const { owner, repo } = context.repo;
            const runs = await github.rest.actions.listWorkflowRunsForRepo({
              owner, repo, per_page: 50, head_sha: sha
            });
            const ciRun = runs.data.workflow_runs.find(r => r.name === "CI" && r.head_sha === sha);
            if (!ciRun) {
              core.setFailed("No CI run found for this commit.");
              return;
            }
            if (ciRun.status !== "completed" || ciRun.conclusion !== "success") {
              core.setFailed(`CI run not successful: status=${ciRun.status} conclusion=${ciRun.conclusion}`);
            } else {
              core.info("CI success verified.");
            }

  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    needs: require-ci
    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Set IMAGE_TAG
        id: tag
        run: |
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            echo "IMAGE_TAG=${{ github.event.inputs.image_tag }}" >> $GITHUB_ENV
            echo "image_tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            TAG="sha-$(git rev-parse --short=12 HEAD)"
            echo "IMAGE_TAG=$TAG" >> $GITHUB_ENV
            echo "image_tag=$TAG" >> $GITHUB_OUTPUT
          fi

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push backend
        uses: docker/build-push-action@v5
        with:
          context: .
          file: backend/Dockerfile.prod
          push: true
          tags: |
            ghcr.io/${{ env.GHCR_OWNER }}/${{ env.GHCR_REPO }}/backend:${{ env.IMAGE_TAG }}

      - name: Build and push frontend
        uses: docker/build-push-action@v5
        with:
          context: .
          file: frontend/Dockerfile.prod
          push: true
          tags: |
            ghcr.io/${{ env.GHCR_OWNER }}/${{ env.GHCR_REPO }}/frontend:${{ env.IMAGE_TAG }}

  deploy-staging:
    name: Deploy to Staging
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - uses: actions/checkout@v4
      - name: Set IMAGE_TAG
        run: echo "IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}" >> $GITHUB_ENV
      - name: Sync stack file to staging host
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.STAGING_SSH_HOST }}
          username: ${{ secrets.STAGING_SSH_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: 2222
          source: 'deploy/stack.staging.yml'
          target: '${{ secrets.STAGING_APP_DIR }}'
          strip_components: 1
      - name: Sync scripts to staging host
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.STAGING_SSH_HOST }}
          username: ${{ secrets.STAGING_SSH_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: 2222
          source: 'scripts/'
          target: '${{ secrets.STAGING_APP_DIR }}'
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.1.0
        with:
          host: ${{ secrets.STAGING_SSH_HOST }}
          username: ${{ secrets.STAGING_SSH_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: 2222
          script: |
            set -euo pipefail
            export GHCR_OWNER=${{ env.GHCR_OWNER }}
            export GHCR_REPO=${{ env.GHCR_REPO }}
            export IMAGE_TAG=${{ env.IMAGE_TAG }}
            # Login to GHCR using fine-grained read-only token
            docker login ghcr.io -u "${{ secrets.STAGING_GHCR_READ_USER }}" -p "${{ secrets.STAGING_GHCR_READ_TOKEN }}"
            cd "${{ secrets.STAGING_APP_DIR }}"
            # Deploy the stack (backend will start but we'll run migrations first)
            IMAGE_TAG="${IMAGE_TAG}" docker stack deploy -c stack.staging.yml fitfolio-staging

            echo "Waiting for database to be ready..."
            # Wait for PostgreSQL to be ready (max 60 seconds)
            db_ready=false
            for i in {1..30}; do
              db_cid=$(docker ps --filter "name=fitfolio-staging_db" --filter "status=running" --format '{{.ID}}' | head -n1)
              if [ -n "$db_cid" ]; then
                if docker exec -i "$db_cid" pg_isready -h localhost -p 5432 >/dev/null 2>&1; then
                  echo "PostgreSQL is ready!"
                  db_ready=true
                  break
                fi
              fi
              echo "PostgreSQL not ready yet, waiting... ($i/30)"
              sleep 2
            done

            if [ "$db_ready" = false ]; then
              echo "ERROR: PostgreSQL did not become ready within 60 seconds"
              exit 1
            fi

            echo ""
            echo "Running database migrations in one-off container..."
            # Create a one-off service for migrations (not in the app workers)
            # This avoids OOM from running migrations alongside 4 gunicorn workers
            docker service create \
              --name fitfolio-staging-migrate \
              --network fitfolio-staging_default \
              --secret source=postgres_password_staging,target=postgres_password,mode=0444 \
              --secret source=smtp_username_staging,target=smtp_username,mode=0444 \
              --secret source=smtp_password_staging,target=smtp_password,mode=0444 \
              --env POSTGRES_HOST=db \
              --env POSTGRES_PORT=5432 \
              --env POSTGRES_DB=fitfolio_staging \
              --env POSTGRES_USER=fitfolio_user \
              --env USE_DOCKER_SECRETS=true \
              --env PYTHONUNBUFFERED=1 \
              --restart-condition none \
              --with-registry-auth \
              --detach \
              ghcr.io/${GHCR_OWNER}/${GHCR_REPO}/backend:${IMAGE_TAG} \
              bash -c 'python3 -u /app/scripts/preflight_check.py && python3 -u /app/scripts/db_stamp_check.py && alembic -c /app/alembic.ini upgrade head'

            # Wait for migration service to complete (max 5 minutes)
            echo "Waiting for migrations to complete (max 300s)..."
            migration_complete=false
            for i in {1..150}; do
              state=$(docker service ps fitfolio-staging-migrate --format '{{.CurrentState}}' --filter "desired-state=shutdown" | head -n1)
              if echo "$state" | grep -q "Complete"; then
                echo "Migrations completed successfully!"
                migration_complete=true
                break
              elif echo "$state" | grep -q "Failed"; then
                echo "ERROR: Migration service failed"
                docker service logs fitfolio-staging-migrate
                docker service rm fitfolio-staging-migrate
                exit 1
              fi
              echo "Migration still running... ($i/150)"
              sleep 2
            done

            # Show migration logs
            echo ""
            echo "=== Migration logs ==="
            docker service logs fitfolio-staging-migrate

            # Clean up migration service (always remove, success or failure)
            docker service rm fitfolio-staging-migrate

            # Check if migrations timed out
            if [ "$migration_complete" = false ]; then
              echo "ERROR: Migration did not complete within 300 seconds"
              exit 1
            fi

            echo ""
            echo "Waiting for backend to be healthy..."
            # Now wait for backend to be running and healthy
            cid=""
            for i in {1..60}; do
              cid=$(docker ps --filter "name=fitfolio-staging_backend" --filter "status=running" --format '{{.ID}}' | head -n1)
              if [ -n "$cid" ]; then
                health=$(docker inspect --format='{{.State.Health.Status}}' "$cid" 2>/dev/null || echo "none")
                if [ "$health" = "healthy" ]; then
                  echo "Backend container is healthy: $cid"
                  break
                elif [ "$health" = "none" ]; then
                  echo "Backend container has no healthcheck, proceeding anyway: $cid"
                  break
                else
                  echo "Waiting for healthy status (currently: $health)... ($i/60)"
                fi
              else
                echo "Waiting for backend to start... ($i/60)"
              fi
              sleep 2
            done

            if [ -z "$cid" ]; then
              echo "ERROR: Backend did not become healthy within 120 seconds" >&2
              exit 1
            fi

            echo "Deployment successful!"

  smoke-staging:
    name: Smoke Tests (Staging)
    needs: deploy-staging
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run smoke tests via SSH
        uses: appleboy/ssh-action@v1.1.0
        with:
          host: ${{ secrets.STAGING_SSH_HOST }}
          username: ${{ secrets.STAGING_SSH_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: 2222
          script: |
            set -euo pipefail
            cd "${{ secrets.STAGING_APP_DIR }}"

            # Copy smoke script from repo (already synced during deploy)
            if [ ! -f scripts/smoke_deploy.sh ]; then
              echo "ERROR: smoke_deploy.sh not found in ${{ secrets.STAGING_APP_DIR }}/scripts/"
              exit 1
            fi

            # Run smoke tests from staging server (can resolve internal DNS)
            bash scripts/smoke_deploy.sh "https://fitfolio-staging.rutabagel.com" "${{ github.event.inputs.extended_smoke || 'false' }}"

  promote-prod:
    name: Promote to Production (Manual)
    needs: smoke-staging
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://fitfolio.rutabagel.com
    steps:
      - uses: actions/checkout@v4
      - name: Set IMAGE_TAG
        run: echo "IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}" >> $GITHUB_ENV
      - name: Sync compose files to prod host
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.PROD_SSH_HOST }}
          username: ${{ secrets.PROD_SSH_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          port: 2222
          source: 'compose.prod.yml'
          target: '${{ secrets.PROD_APP_DIR }}'
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.1.0
        with:
          host: ${{ secrets.PROD_SSH_HOST }}
          username: ${{ secrets.PROD_SSH_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          port: 2222
          script: |
            set -euo pipefail
            export GHCR_OWNER=${{ env.GHCR_OWNER }}
            export GHCR_REPO=${{ env.GHCR_REPO }}
            export IMAGE_TAG=${{ env.IMAGE_TAG }}
            docker login ghcr.io -u ${{ github.actor }} -p ${{ secrets.GITHUB_TOKEN }}
            cd "${{ secrets.PROD_APP_DIR }}"
            docker compose -f compose.prod.yml pull
            docker compose -f compose.prod.yml up -d
            docker compose -f compose.prod.yml exec -T backend bash -lc "alembic -c /app/alembic.ini upgrade head"
